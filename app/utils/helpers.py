"""
Utility Helper Functions
Common functions for formatting, data processing, and file operations
"""

import os
import json
from datetime import datetime
from typing import Dict, List, Any, Optional
import logging
import base64

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def format_analysis_results(results: Dict[str, str], paper_name: str) -> str:
    """
    Format analysis results into a readable text report.
    
    Args:
        results: Dictionary containing analysis results
        paper_name: Name of the analyzed paper
        
    Returns:
        Formatted text report
    """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    report = f"""
# AI Research Paper Analysis Report
**Paper**: {paper_name}
**Generated**: {timestamp}
**Tool**: AI Research Paper Assistant (Powered by Google Gemini)

{'='*80}

"""
    
    # Add each analysis section if it exists
    sections = {
        'summary': '📝 EXECUTIVE SUMMARY',
        'methodology': '🔬 METHODOLOGY ANALYSIS',
        'citations': '📚 CITATIONS & REFERENCES',
        'gaps': '🔍 RESEARCH GAPS IDENTIFIED',
        'keywords': '🏷️ KEY TERMS & CONCEPTS',
        'detailed': '📋 DETAILED ANALYSIS'
    }
    
    for key, title in sections.items():
        if key in results and results[key]:
            report += f"\n## {title}\n\n{results[key]}\n\n{'='*80}\n"
    
    report += f"\n\n*Report generated by AI Research Paper Assistant*\n*Powered by Google Gemini AI*"
    
    return report

def create_download_link(data: str, filename: str, mime_type: str = "text/plain") -> str:
    """
    Create a download link for data.
    
    Args:
        data: Data to be downloaded
        filename: Name of the file
        mime_type: MIME type of the file
        
    Returns:
        Base64 encoded download link
    """
    try:
        b64_data = base64.b64encode(data.encode()).decode()
        href = f'<a href="data:{mime_type};base64,{b64_data}" download="{filename}">Download {filename}</a>'
        return href
    except Exception as e:
        logger.error(f"Error creating download link: {str(e)}")
        return "Error creating download link"

def save_analysis_results(results: Dict[str, str], paper_name: str, output_dir: str = "outputs") -> str:
    """
    Save analysis results to a JSON file.
    
    Args:
        results: Analysis results dictionary
        paper_name: Name of the paper
        output_dir: Directory to save results
        
    Returns:
        Path to saved file
    """
    try:
        # Create output directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)
        
        # Create filename with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_paper_name = "".join(c for c in paper_name if c.isalnum() or c in (' ', '-', '_')).rstrip()
        filename = f"analysis_{safe_paper_name}_{timestamp}.json"
        filepath = os.path.join(output_dir, filename)
        
        # Prepare data for saving
        save_data = {
            "paper_name": paper_name,
            "timestamp": datetime.now().isoformat(),
            "analysis_results": results,
            "metadata": {
                "tool_version": "1.0.0",
                "ai_model": "gemini-1.5-flash"
            }
        }
        
        # Save to JSON
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(save_data, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Analysis results saved to: {filepath}")
        return filepath
        
    except Exception as e:
        logger.error(f"Error saving analysis results: {str(e)}")
        return ""

def load_analysis_results(filepath: str) -> Optional[Dict[str, Any]]:
    """
    Load previously saved analysis results.
    
    Args:
        filepath: Path to the saved results file
        
    Returns:
        Loaded analysis data or None if failed
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        logger.info(f"Analysis results loaded from: {filepath}")
        return data
        
    except Exception as e:
        logger.error(f"Error loading analysis results: {str(e)}")
        return None

def clean_filename(filename: str) -> str:
    """
    Clean filename to be safe for file systems.
    
    Args:
        filename: Original filename
        
    Returns:
        Cleaned filename
    """
    # Remove or replace invalid characters
    invalid_chars = '<>:"/\\|?*'
    for char in invalid_chars:
        filename = filename.replace(char, '_')
    
    # Remove excessive dots and spaces
    filename = filename.strip('. ')
    
    # Limit length
    if len(filename) > 100:
        name, ext = os.path.splitext(filename)
        filename = name[:96] + ext
    
    return filename

def validate_pdf_file(file_path: str) -> bool:
    """
    Validate if the file is a proper PDF.
    
    Args:
        file_path: Path to the file
        
    Returns:
        True if valid PDF, False otherwise
    """
    try:
        if not os.path.exists(file_path):
            return False
        
        # Check file extension
        if not file_path.lower().endswith('.pdf'):
            return False
        
        # Check file size (max 10MB)
        file_size = os.path.getsize(file_path)
        max_size = 10 * 1024 * 1024  # 10MB
        if file_size > max_size:
            logger.warning(f"File too large: {file_size / 1024 / 1024:.2f}MB")
            return False
        
        # Check if file can be opened (basic validation)
        with open(file_path, 'rb') as f:
            header = f.read(4)
            if header != b'%PDF':
                return False
        
        return True
        
    except Exception as e:
        logger.error(f"Error validating PDF: {str(e)}")
        return False

def format_file_size(size_bytes: int) -> str:
    """
    Format file size in human-readable format.
    
    Args:
        size_bytes: Size in bytes
        
    Returns:
        Formatted size string
    """
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024**2:
        return f"{size_bytes / 1024:.1f} KB"
    elif size_bytes < 1024**3:
        return f"{size_bytes / (1024**2):.1f} MB"
    else:
        return f"{size_bytes / (1024**3):.1f} GB"

def get_analysis_summary_stats(results: Dict[str, str]) -> Dict[str, int]:
    """
    Get summary statistics about the analysis results.
    
    Args:
        results: Analysis results dictionary
        
    Returns:
        Statistics dictionary
    """
    stats = {
        'total_sections': len(results),
        'total_characters': sum(len(text) for text in results.values()),
        'total_words': sum(len(text.split()) for text in results.values()),
        'sections_generated': len([k for k, v in results.items() if v and not v.startswith('Error')])
    }
    
    return stats

def create_analysis_metadata(paper_name: str, analysis_options: Dict[str, bool]) -> Dict[str, Any]:
    """
    Create metadata for an analysis session.
    
    Args:
        paper_name: Name of the paper being analyzed
        analysis_options: Options selected for analysis
        
    Returns:
        Metadata dictionary
    """
    metadata = {
        'paper_name': paper_name,
        'timestamp': datetime.now().isoformat(),
        'analysis_options': analysis_options,
        'tool_version': '1.0.0',
        'ai_model': 'gemini-1.5-flash'
    }
    
    return metadata

def truncate_text(text: str, max_length: int = 100, suffix: str = "...") -> str:
    """
    Truncate text to specified length.
    
    Args:
        text: Text to truncate
        max_length: Maximum length
        suffix: Suffix to add when truncating
        
    Returns:
        Truncated text
    """
    if len(text) <= max_length:
        return text
    
    return text[:max_length - len(suffix)] + suffix

# Example usage and testing
if __name__ == "__main__":
    # Test utility functions
    sample_results = {
        'summary': 'This is a test summary of the paper...',
        'keywords': 'AI, machine learning, neural networks'
    }
    
    formatted_report = format_analysis_results(sample_results, "test_paper.pdf")
    print("Sample formatted report created!")
    
    stats = get_analysis_summary_stats(sample_results)
    print(f"Analysis stats: {stats}")
    
    print("Helper utilities loaded successfully!")